/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "remote_fifo.h"
#include "../remote_fifo.h"
#include <map>
#include <semaphore.h>
#include <string>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "../data_queue.h"


class fifo_info {
public:
	std::string name;
	data_queue	data;
	sem_t		lock;
	int 		use_count;

	// TODO dodaÄ‡ 'set<int> handles'

	fifo_info(std::string n)
	{
		name = n;
		sem_init(&lock, 1, 1);
		use_count = 0;
	}

	~fifo_info()
	{
		sem_destroy(&lock);
	}
};

#define fifos_iter std::map<std::string, fifo_info*>::iterator
#define handles_iter std::map<int, fifo_info*>::iterator
std::map<std::string, fifo_info*> fifos;
std::map<int, fifo_info*> handles;

sem_t overal_sem;
sem_t fifos_sem;
sem_t handles_sem;
int next_handle = 1;


/// -- -- --
CLIENT* __aquire_client_callback(struct svc_req* req, int uid /*sockaddr_in* client_addr*/)
{
    CLIENT *c = NULL;
    char host[200];

    printf("Client: %d\n", uid);

    sockaddr_in* client_addr = svc_getcaller(req->rq_xprt);

	inet_ntop(client_addr->sin_family, &client_addr->sin_addr, host, sizeof(host));
//	printf("HOST: %s\n", host);

	c = clnt_create (host, REMOTE_FIFO, CLIENT_API+uid, "tcp");
	if (c == NULL)
	{
		clnt_pcreateerror (host);
		exit (1);
	}

    return c;
}

/// -- -- --
void __release_client_callback(CLIENT* c)
{
	clnt_destroy (c);
}



/**
 *
 */
void server_rf_init()
{
	sem_init(&overal_sem, 0, 1);
	sem_init(&fifos_sem, 0, 1);
	sem_init(&handles_sem, 0, 1);
	printf("@ Init done\n");
}

typedef clnt_stat (*management_rf_res_func)(management_rf_res*,int*,CLIENT*);
typedef clnt_stat (*data_rf_res_func)(data_rf_res*,int*,CLIENT*);

struct client_thread {
	void* res;
	void* func;
	CLIENT* client;
};
typedef client_thread client_mngm_thread;

void free_rf_res(management_rf_res* res)
{
	free(res->name);
	free(res->callback.callback_val);
	free(res->data.data_val);
	free(res);
}

void free_rf_res(data_rf_res* res)
{
	free(res->buf.buf_val);
	free(res->callback.callback_val);
	free(res->data.data_val);
	free(res);
}

void* mngm_result_th(void* d)
{
	client_mngm_thread* data = (client_mngm_thread*)d;
	management_rf_res_func func = (management_rf_res_func)data->func;
	management_rf_res *res = (management_rf_res*)data->res;

	int val = 0;
	func(res, &val, data->client);

	__release_client_callback(data->client);
	free_rf_res(res);
	free(data);
	return NULL;
}

void* data_result_th(void* d)
{
	client_mngm_thread* data = (client_mngm_thread*)d;
	data_rf_res_func func = (data_rf_res_func)data->func;
	data_rf_res *res = (data_rf_res*)data->res;

	int val = 0;
	func(res, &val, data->client);

	__release_client_callback(data->client);
	free_rf_res(res);
	free(data);
	return NULL;
}

void call_client_mngm_result(int code, struct svc_req *rqstp, management_rf* argp, management_rf_res_func func)
{
	printf(" * -call mngm: %d : %s : len %d\n", code, argp->name, argp->data.data_len);fflush(NULL);
	CLIENT *c = __aquire_client_callback(rqstp, argp->uid);
	struct management_rf_res *res = (management_rf_res*)malloc(sizeof(struct management_rf_res));
	res->code = code;
	res->name = strdup(argp->name);

	res->data.data_len = argp->data.data_len;
	res->data.data_val = (char*)malloc(argp->data.data_len);
	memcpy(res->data.data_val, argp->data.data_val, argp->data.data_len);

	res->callback.callback_len = argp->callback.callback_len;
	res->callback.callback_val = (char*)malloc(argp->callback.callback_len);
	memcpy(res->callback.callback_val, argp->callback.callback_val, argp->callback.callback_len);
	int val = 0;
	//create_rf_res__101(&res, &val, c);
	////func(&res, &val, c);
	client_thread* data = (client_thread*)malloc(sizeof(client_thread));
	data->res = res;
	data->func = (void*)func;
	data->client = c;
	//__release_client_callback(c);
	pthread_t th;
	pthread_create(&th, NULL, mngm_result_th, data);
	pthread_detach(th);
}

void call_client_data_result(int code, void* buf, int buf_len, struct svc_req *rqstp, data_rf* argp, data_rf_res_func func)
{
	printf(" * -call data: %d : %d : buf len: %d, data len %d\n", code, argp->descriptor, buf_len, argp->data.data_len);fflush(NULL);
	CLIENT *c = __aquire_client_callback(rqstp, argp->uid);
	data_rf_res* res = (data_rf_res*)malloc(sizeof(data_rf_res));
	res->descriptor = argp->descriptor;
	res->code = code;

	res->buf.buf_len = buf_len;
	res->buf.buf_val = (char*)malloc(buf_len);
	memcpy(res->buf.buf_val, buf, buf_len);

	res->data.data_len = argp->data.data_len;
	res->data.data_val = (char*)malloc(argp->data.data_len);
	memcpy(res->data.data_val, argp->data.data_val, argp->data.data_len);

	res->callback.callback_len = argp->callback.callback_len;
	res->callback.callback_val = (char*)malloc(argp->callback.callback_len);
	memcpy(res->callback.callback_val, argp->callback.callback_val, argp->callback.callback_len);

	int val = 0;
	client_thread* data = (client_thread*)malloc(sizeof(client_thread));
	data->res = (void*)res;
	data->func = (void*)func;
	data->client = c;
	//__release_client_callback(c);
	pthread_t th;
	pthread_create(&th, NULL, data_result_th, data);
	pthread_detach(th);

	//create_rf_res__101(&res, &val, c);
	//func(&res, &val, c);
	//__release_client_callback(c);
}

/**
 *
 */
bool_t create_rf__1_svc(management_rf *argp, int *result, struct svc_req *rqstp)
{
	//sem_wait(&overal_sem);
	sem_wait(&fifos_sem);

	std::string name(argp->name);
	fifos_iter iter = fifos.find(name);
	if (iter!=fifos.end()) {
		sem_post(&fifos_sem);
		*result = -1;
		return TRUE;
	}

	*result = 0;
	fifos[name] = new fifo_info(name);

	// ta sama kolejnosc - mikro-optymalizacja...
	//sem_post(&overal_sem);
	sem_post(&fifos_sem);

	printf(" # create: %s : %d :: %d\n", name.c_str(), *result, argp->data.data_len);

	call_client_mngm_result(0, rqstp, argp, create_rf_res__101);

	return TRUE;
}

bool_t unlink_rf__1_svc(management_rf *argp, int *result, struct svc_req *rqstp)
{
	std::string name(argp->name);
	sem_wait(&fifos_sem);
	sem_wait(&handles_sem);
	fifos_iter iter = fifos.find(name);
	if (iter==fifos.end())
	{
		printf(" # unlink failed: %s : %d\n", name.c_str(), *result);
		sem_post(&handles_sem);
		sem_post(&fifos_sem);
		*result = -1;
	}
	else
	{
		fifo_info* item = iter->second;

		*result = sem_wait(&(item->lock));
		sem_post(&handles_sem);

		// TODO posprzatac z 'handles'
		fifos.erase(iter);
		delete item;

		sem_post(&fifos_sem);

		printf(" # unlink: %s : %d\n", name.c_str(), *result);
	}
	call_client_mngm_result(0, rqstp, argp, unlink_rf_res__101);

	return TRUE;
}

bool_t open_rf__1_svc(management_rf *argp, int *result, struct svc_req *rqstp)
{
	std::string name(argp->name);

	sem_wait(&fifos_sem);
	fifos_iter iter = fifos.find(name);
	if (iter==fifos.end())
	{
		sem_post(&fifos_sem);
		*result = -1;
		return TRUE;
	}

	sem_wait(&(iter->second->lock));
	sem_post(&fifos_sem);

	sem_wait(&handles_sem);
	while (handles.find(next_handle)!=handles.end())
	{
		next_handle++;
	}
	handles[next_handle] = iter->second;
	*result = next_handle;
	// TODO handles w obiekcie
	next_handle++;
	sem_post(&handles_sem);

	sem_post(&(iter->second->lock));

	printf(" # open: %s : %d\n", name.c_str(), *result);
	call_client_mngm_result(*result, rqstp, argp, open_rf_res__101);

	return TRUE;
}

bool_t close_rf__1_svc(data_rf *argp, int *result, struct svc_req *rqstp)
{
	sem_wait(&handles_sem);
	int handle = argp->descriptor;
	handles_iter iter = handles.find(handle);
	if (iter==handles.end())
	{
		*result = -1;
		sem_post(&handles_sem);
		return TRUE;
	}
	std::string name(iter->second->name);
	handles.erase(iter);
	sem_post(&handles_sem);

	*result = 0;

	printf(" # close: %s : %d\n", name.c_str(), *result);
	management_rf argp2;
	argp2.name = (char*)name.c_str();
	argp2.data.data_len = argp->data.data_len;
	argp2.data.data_val = argp->data.data_val;
	argp2.callback.callback_len = argp->callback.callback_len;
	argp2.callback.callback_val = argp->callback.callback_val;
	argp2.uid = argp->uid;
	call_client_mngm_result(*result, rqstp, &argp2, close_rf_res__101);
	return TRUE;
}

bool_t write_rf__1_svc(data_rf *argp, int *result, struct svc_req *rqstp)
{
	printf(" # write: %d, len: %d\n", argp->descriptor, argp->buf.buf_len);
	sem_wait(&handles_sem);
	int handle = argp->descriptor;
	handles_iter iter = handles.find(handle);
	if (iter!=handles.end())
	{
		sem_wait(&(iter->second->lock));
		sem_post(&handles_sem);
		iter->second->data.write(argp->buf.buf_len, argp->buf.buf_val);
		sem_post(&(iter->second->lock));
		*result = 0;

		/*
		std::string name(iter->second->name);
		printf("write: [%s] : len=%d : code=%d :: MSG: [", name.c_str(), argp->buf.buf_len, *result);
		for (int i=0; i<argp->buf.buf_len; i++) printf("%1c[%02x]", argp->buf.buf_val[i], argp->buf.buf_val[i]);
		printf("]\n");
		*/
	}
	else
	{
		sem_post(&handles_sem);
		*result = -1;

		printf(" # write: [%d] : FAILED :%d\n", handle, *result);
	}

	call_client_data_result(*result, NULL, 0, rqstp, argp, write_rf_res__101);

	return TRUE;
}

bool_t read_rf__1_svc(data_rf *argp, int *result, struct svc_req *rqstp)
{
	int handle = argp->descriptor;

	unsigned long long size = 0;
	memcpy(&size, argp->buf.buf_val, sizeof(size));

	printf(" # read: %d, len: %d (real len: %d)\n", argp->descriptor, argp->buf.buf_len, size);

	sem_wait(&handles_sem);
	handles_iter iter = handles.find(handle);
	if (iter!=handles.end())
	{
		unsigned long long size = 0;
		int delta = argp->buf.buf_len;
		void* buffer = NULL;
		memcpy(&size, argp->buf.buf_val, sizeof(size));
		memcpy(&buffer, &argp->buf.buf_val[sizeof(size)], sizeof(buffer));
		argp->buf.buf_val = (char*)realloc(argp->buf.buf_val, size + argp->buf.buf_len);
		argp->buf.buf_len += size;

		*result = size;
		sem_wait(&(iter->second->lock));
		sem_post(&handles_sem);
		iter->second->data.read(size, &argp->buf.buf_val[delta]);
		sem_post(&(iter->second->lock));

		std::string name(iter->second->name);
		/*
		printf("read: [%s] : len=%d : code=%d :: MSG: [", name.c_str(), argp->buf.buf_len, *result);
		for (int i=0; i<size; i++) printf("%02x:", argp->buf.buf_val[i+delta]);
		printf("]\n");
		*/
	}
	else
	{
		sem_post(&handles_sem);
		*result = -1;
	}
	call_client_data_result(*result, argp->buf.buf_val, argp->buf.buf_len, rqstp, argp, read_rf_res__101);
	return TRUE;
}

int remote_fifo_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}

bool_t create_rf_res__101_svc(management_rf_res *argp, int *result, struct svc_req *rqstp)
{
	rf_man_callback *callback = (rf_man_callback*)argp->callback.callback_val;
	int code = argp->code;
	char* name = argp->name;
	void* data = NULL;
	assert(sizeof(data)==argp->data.data_len);
	memcpy(&data, argp->data.data_val, sizeof(data));
	printf(" => create_rf_res__101_svc: %s / %s\n", name, (char*)data);
	(*callback)(code, name, data);

	*result = 0;

	return TRUE;
}

bool_t unlink_rf_res__101_svc(management_rf_res *argp, int *result, struct svc_req *rqstp)
{
	rf_man_callback *callback = (rf_man_callback*)argp->callback.callback_val;
	int code = argp->code;
	char* name = argp->name;
	void* data = NULL;
	assert(sizeof(data)==argp->data.data_len);
	memcpy(&data, argp->data.data_val, sizeof(data));
	printf(" => unlink_rf_res__101_svc: %s / %s\n", name, (char*)data);
	(*callback)(code, name, data);

	*result = 0;

	return TRUE;
}

bool_t open_rf_res__101_svc(management_rf_res *argp, int *result, struct svc_req *rqstp)
{
	rf_man_callback *callback = (rf_man_callback*)argp->callback.callback_val;
	int code = argp->code;
	char* name = argp->name;
	void* data = NULL;
	assert(sizeof(data)==argp->data.data_len);
	memcpy(&data, argp->data.data_val, sizeof(data));
	printf(" => open_rf_res__101_svc: %s / %s\n", name, (char*)data);
	(*callback)(code, name, data);

	*result = 0;

	return TRUE;
}

bool_t close_rf_res__101_svc(management_rf_res *argp, int *result, struct svc_req *rqstp)
{
	rf_man_callback *callback = (rf_man_callback*)argp->callback.callback_val;
	int code = argp->code;
	char* name = argp->name;
	void* data = NULL;
	assert(sizeof(data)==argp->data.data_len);
	memcpy(&data, argp->data.data_val, sizeof(data));
	printf(" => close_rf_res__101_svc: %s / %s\n", name, (char*)data);
	(*callback)(code, name, data);

	*result = 0;

	return TRUE;
}

bool_t write_rf_res__101_svc(data_rf_res *argp, int *result, struct svc_req *rqstp)
{
	rf_rw_callback *callback = (rf_rw_callback*)argp->callback.callback_val;
	int handle = argp->descriptor;
	int code = argp->code;
	void* data = NULL;

	assert(sizeof(data)==argp->data.data_len);
	memcpy(&data, argp->data.data_val, sizeof(data));
	printf(" => write_rf_res__101_svc: %d/%d, len: %d, data: %lld\n", handle, code, argp->buf.buf_len, (char*)data);
	//(int handle, int code, void* buf, int len, void* data);
	(*callback)(handle, code, NULL, 0, data);

	*result = 0;

	return TRUE;
}

bool_t read_rf_res__101_svc(data_rf_res *argp, int *result, struct svc_req *rqstp)
{
	rf_rw_callback *callback = (rf_rw_callback*)argp->callback.callback_val;
	int handle = argp->descriptor;
	int code = argp->code;
	void* data = NULL;

	unsigned long long size = 0;
	char* buffer = NULL;
	int delta = sizeof(size) + sizeof(buffer);
	memcpy(&size, argp->buf.buf_val, sizeof(size));
	memcpy(&buffer, &argp->buf.buf_val[sizeof(size)], sizeof(buffer));
	memcpy(buffer, &argp->buf.buf_val[delta], size);


	assert(sizeof(data)==argp->data.data_len);
	memcpy(&data, argp->data.data_val, sizeof(data));
	printf(" => read_rf_res__101_svc: %d/%d, len: %d, data: %lld\n", handle, code, size, (char*)data);
	//(int handle, int code, void* buf, int len, void* data);
	(*callback)(handle, code, buffer, size, data);

	*result = 0;

	return TRUE;
}

int remote_fifo_101_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
