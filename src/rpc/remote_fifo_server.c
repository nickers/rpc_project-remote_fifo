/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "remote_fifo.h"
#include "../remote_fifo.h"
#include <map>
#include <semaphore.h>
#include <string>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include "../data_queue.h"


class fifo_info {
public:
	std::string name;
	data_queue	data;
	sem_t		lock;
	int 		use_count;

	// TODO dodaÄ‡ 'set<int> handles'

	fifo_info(std::string n)
	{
		name = n;
		sem_init(&lock, 1, 1);
		use_count = 0;
	}

	~fifo_info()
	{
		sem_destroy(&lock);
	}
};

#define fifos_iter std::map<std::string, fifo_info*>::iterator
#define handles_iter std::map<int, fifo_info*>::iterator
std::map<std::string, fifo_info*> fifos;
std::map<int, fifo_info*> handles;

sem_t overal_sem;
sem_t fifos_sem;
sem_t handles_sem;
int next_handle = 1;


/// -- -- --
CLIENT* __aquire_client_callback(struct svc_req* req /*sockaddr_in* client_addr*/)
{
    CLIENT *c = NULL;
    char host[200];

    sockaddr_in* client_addr = svc_getcaller(req->rq_xprt);

	inet_ntop(client_addr->sin_family, &client_addr->sin_addr, host, sizeof(host));
	printf("HOST: %s\n", host);

	c = clnt_create (host, REMOTE_FIFO, CLIENT_API, "tcp");
	if (c == NULL)
	{
		clnt_pcreateerror (host);
		exit (1);
	}

    return c;
}

/// -- -- --
void __release_client_callback(CLIENT* c)
{
	clnt_destroy (c);
}



/**
 *
 */
void server_rf_init()
{
	sem_init(&overal_sem, 1, 1);
	sem_init(&fifos_sem, 1, 1);
	sem_init(&handles_sem, 1, 1);
	printf("init done\n");
}

/**
 *
 */
bool_t create_rf__1_svc(management_rf *argp, int *result, struct svc_req *rqstp)
{
	//sem_wait(&overal_sem);
	sem_wait(&fifos_sem);

	std::string name(argp->name);
	fifos_iter iter = fifos.find(name);
	if (iter!=fifos.end()) {
		sem_post(&fifos_sem);
		*result = -1;
		return TRUE;
	}

	*result = 0;
	fifos[name] = new fifo_info(name);

	// ta sama kolejnosc - mikro-optymalizacja... 
	//sem_post(&overal_sem);
	sem_post(&fifos_sem);

	printf("create: %s : %d\n", name.c_str(), *result);

	CLIENT *c = __aquire_client_callback(rqstp);
	management_rf_res res;
	res.code = 0;
	res.name = argp->name;
	res.data.data_len = argp->data.data_len;
	res.data.data_val = argp->data.data_val;
	res.callback.callback_len = argp->callback.callback_len;
	res.callback.callback_val = argp->callback.callback_val;
	int val = 0;
	create_rf_res__101(&res, &val, c);
	__release_client_callback(c);
	printf(">>\n");

	return TRUE;
}

bool_t unlink_rf__1_svc(management_rf *argp, int *result, struct svc_req *rqstp)
{
	std::string name(argp->name);
	sem_wait(&fifos_sem);
	sem_wait(&handles_sem);
	fifos_iter iter = fifos.find(name);
	if (iter==fifos.end())
	{
		printf("unlink failed: %s : %d\n", name.c_str(), *result);
		sem_post(&handles_sem);
		sem_post(&fifos_sem);
		*result = -1;
		return TRUE;
	}
	fifo_info* item = iter->second;

	*result = sem_wait(&(item->lock));
	sem_post(&handles_sem);

	// TODO posprzatac z 'handles'
	fifos.erase(iter);
	delete item;
	
	sem_post(&fifos_sem);

	printf("unlink: %s : %d\n", name.c_str(), *result);

	return TRUE;
}

bool_t open_rf__1_svc(management_rf *argp, int *result, struct svc_req *rqstp)
{
	std::string name(argp->name);
	
	sem_wait(&fifos_sem);
	fifos_iter iter = fifos.find(name);
	if (iter==fifos.end())
	{
		sem_post(&fifos_sem);
		*result = -1;
		return TRUE;
	}

	sem_wait(&(iter->second->lock));
	sem_post(&fifos_sem);

	sem_wait(&handles_sem);
	while (handles.find(next_handle)!=handles.end())
	{
		next_handle++;
	}
	handles[next_handle] = iter->second;
	*result = next_handle;
	// TODO handles w obiekcie
	next_handle++;
	sem_post(&handles_sem);

	sem_post(&(iter->second->lock));

	printf("open: %s : %d\n", name.c_str(), *result);

	return TRUE;
}

bool_t close_rf__1_svc(data_rf *argp, int *result, struct svc_req *rqstp)
{
	sem_wait(&handles_sem);
	int handle = argp->descriptor;
	handles_iter iter = handles.find(handle);
	if (iter==handles.end())
	{
		*result = -1;
		return TRUE;
	}
	std::string name(iter->second->name);
	handles.erase(iter);
	sem_post(&handles_sem);

	*result = 0;

	printf("close: %s : %d\n", name.c_str(), *result);
	return TRUE;
}

bool_t write_rf__1_svc(data_rf *argp, int *result, struct svc_req *rqstp)
{
	sem_wait(&handles_sem);
	int handle = argp->descriptor;
	handles_iter iter = handles.find(handle);
	if (iter!=handles.end())
	{
		sem_wait(&(iter->second->lock));
		sem_post(&handles_sem);
		iter->second->data.write(argp->buf.buf_len, argp->buf.buf_val);
		sem_post(&(iter->second->lock));
		*result = 0;

		std::string name(iter->second->name);
		printf("write: [%s] : len=%d : code=%d :: MSG: [", name.c_str(), argp->buf.buf_len, *result);
		for (int i=0; i<argp->buf.buf_len; i++) printf("%1c[%02x]", argp->buf.buf_val[i], argp->buf.buf_val[i]);
		printf("]\n");
	}
	else
	{
		sem_post(&handles_sem);
		*result = -1;

		printf("write: [?] : FAILED :%d\n", *result);
	}

	return TRUE;
}

bool_t read_rf__1_svc(data_rf *argp, int *result, struct svc_req *rqstp)
{
	sem_wait(&handles_sem);
	int handle = argp->descriptor;
	handles_iter iter = handles.find(handle);
	if (iter!=handles.end())
	{
		sem_wait(&(iter->second->lock));
		sem_post(&handles_sem);
		iter->second->data.read(argp->buf.buf_len, argp->buf.buf_val);
		sem_post(&(iter->second->lock));

		std::string name(iter->second->name);
		printf("read: [%s] : len=%d : code=%d :: MSG: [", name.c_str(), argp->buf.buf_len, *result);
		for (int i=0; i<argp->buf.buf_len; i++) printf("%02x:", argp->buf.buf_val[i]);
		printf("]\n");
	}
	else
	{
		sem_post(&handles_sem);
		*result = -1;
	}
	return TRUE;
}

int remote_fifo_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}

bool_t create_rf_res__101_svc(management_rf_res *argp, int *result, struct svc_req *rqstp)
{
	rf_man_callback *callback = (rf_man_callback*)argp->callback.callback_val;
	char* name = argp->name;
	void* data = argp->data.data_val;
	printf("HERE\n!\n");
	printf(" $$$ %d %s %s\n", callback, name, data);
	(*callback)(0, name, data);

	*result = 0;

	return TRUE;
}

bool_t unlink_rf_res__101_svc(management_rf_res *argp, int *result, struct svc_req *rqstp)
{
	bool_t retval;

	/*
	 * insert server code here
	 */

	return retval;
}

bool_t open_rf_res__101_svc(management_rf_res *argp, int *result, struct svc_req *rqstp)
{
	bool_t retval;

	/*
	 * insert server code here
	 */

	return retval;
}

bool_t close_rf_res__101_svc(management_rf_res *argp, int *result, struct svc_req *rqstp)
{
	bool_t retval;

	/*
	 * insert server code here
	 */

	return retval;
}

bool_t write_rf_res__101_svc(data_rf_res *argp, int *result, struct svc_req *rqstp)
{
	bool_t retval;

	/*
	 * insert server code here
	 */

	return retval;
}

bool_t read_rf_res__101_svc(data_rf_res *argp, int *result, struct svc_req *rqstp)
{
	bool_t retval;

	/*
	 * insert server code here
	 */

	return retval;
}

int remote_fifo_101_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
